/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Account Management API
 * API for managing accounts, users, creating API keys, uploading trusted certificates
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require("superagent");
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

/**
 * This object represents an account creation request.
 */
export interface AccountCreationReq {
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "admin_password"?: string;
    /**
     * The username of the admin user to be created, containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "admin_name"?: string;
    /**
     * The full name of the admin user to be created.
     */
    "admin_full_name"?: string;
    /**
     * The end market of the account to be created.
     */
    "end_market": string;
    /**
     * The email address of the account admin, not longer than 254 characters.
     */
    "admin_email"?: string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account creation response.
 */
export interface AccountCreationResp {
    /**
     * The end market of the account to be created.
     */
    "end_market": string;
    /**
     * The ID of the admin user created.
     */
    "admin_id": string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The username of the admin user to be created, containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "admin_name"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "admin_password"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The admin API key created for the account.
     */
    "admin_key"?: string;
    /**
     * The full name of the admin user to be created.
     */
    "admin_full_name"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * The email address of the account admin, not longer than 254 characters.
     */
    "admin_email"?: string;
}

/**
 * This object represents an account in requests and responses.
 */
export namespace AccountInfo {
    export type StatusEnum = "ENROLLING" | "ACTIVE" | "RESTRICTED" | "SUSPENDED";
    export type MfaStatusEnum = "enforced" | "optional";
    export type ObjectEnum = "account";
}
export interface AccountInfo {
    /**
     * Account end market.
     */
    "end_market": string;
    /**
     * The status of the account.
     */
    "status": AccountInfo.StatusEnum;
    /**
     * The password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * Email address of the sales contact.
     */
    "sales_contact"?: string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The postal code part of the postal address.
     */
    "postal_code"?: string;
    /**
     * Account specific custom properties.
     */
    "account_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * Account ID.
     */
    "id": string;
    /**
     * An array of aliases.
     */
    "aliases": Array<string>;
    /**
     * Postal address line 2.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address.
     */
    "city"?: string;
    /**
     * Postal address line 1.
     */
    "address_line1"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The enforcement status of the multi-factor authentication, either 'enforced' or 'optional'.
     */
    "mfa_status"?: AccountInfo.MfaStatusEnum;
    /**
     * The ID of the parent account, if it has any.
     */
    "parent_id"?: string;
    /**
     * The state part of the postal address.
     */
    "state"?: string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The company email address for this account.
     */
    "email"?: string;
    /**
     * The phone number of a representative of the company.
     */
    "phone_number"?: string;
    /**
     * A reference note for updating the status of the account
     */
    "reference_note"?: string;
    /**
     * The name of the company.
     */
    "company"?: string;
    /**
     * Entity name: always 'account'
     */
    "object": AccountInfo.ObjectEnum;
    /**
     * A reason note for updating the status of the account
     */
    "reason"?: string;
    /**
     * Time when upgraded to commercial account in UTC format RFC3339.
     */
    "upgraded_at"?: Date;
    /**
     * The tier level of the account; '0': free tier, '1': commercial account, '2': partner tier. Other values are reserved for the future.
     */
    "tier": string;
    /**
     * List of sub accounts.
     */
    "sub_accounts"?: Array<AccountInfo>;
    /**
     * List of limits as key-value pairs if requested.
     */
    "limits"?: { [key: string]: string; };
    /**
     * The country part of the postal address.
     */
    "country"?: string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * The reference token expiration time in minutes for this account.
     */
    "idle_timeout"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * Indicates how many days (1-180) before account expiration a notification email should be sent.
     */
    "expiration_warning_threshold"?: string;
    /**
     * The name of the contact person for this account.
     */
    "contact"?: string;
    /**
     * List of policies if requested.
     */
    "policies"?: Array<FeaturePolicy>;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
    /**
     * Account template ID.
     */
    "template_id"?: string;
}

export namespace AccountInfoList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface AccountInfoList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": AccountInfoList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<AccountInfo>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: AccountInfoList.OrderEnum;
}

/**
 * This object represents an account in responses.
 */
export interface AccountResponse {
    /**
     * The status of the account.
     */
    "status": string;
    /**
     * Alias of the account.
     */
    "alias"?: string;
    /**
     * The display name for the account.
     */
    "display_name"?: string;
    /**
     * The UUID of the account.
     */
    "id"?: string;
    /**
     * The UUID of the parent account, if it has any.
     */
    "parentId": string;
}

export namespace AccountResponseList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface AccountResponseList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": AccountResponseList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<AccountResponse>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: AccountResponseList.OrderEnum;
}

/**
 * This object represents an account creation request.
 */
export namespace AccountUpdateReq {
    export type MfaStatusEnum = "enforced" | "optional";
}
export interface AccountUpdateReq {
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The enforcement status of setting up the multi-factor authentication. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.
     */
    "mfa_status"?: AccountUpdateReq.MfaStatusEnum;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The reference token expiration time in minutes for this account. Between 1 and 120 minutes.
     */
    "idle_timeout"?: string;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * Properties for this account.
     */
    "account_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * Indicates how many days before account expiration a notification email should be sent. Valid values are: 1-180.
     */
    "expiration_warning_threshold"?: string;
    /**
     * Password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * The end market for this account, not longer than 100 characters.
     */
    "end_market"?: string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
}

/**
 * This object represents an account update request.
 */
export namespace AccountUpdateRootReq {
    export type MfaStatusEnum = "enforced" | "optional";
}
export interface AccountUpdateRootReq {
    /**
     * The end market for this account, not longer than 100 characters.
     */
    "end_market"?: string;
    /**
     * Password policy for this account.
     */
    "password_policy"?: PasswordPolicy;
    /**
     * Email address of the sales contact.
     */
    "sales_contact"?: string;
    /**
     * The company email address for this account, not longer than 254 characters. Required for commercial accounts only.
     */
    "email"?: string;
    /**
     * The postal code part of the postal address, not longer than 100 characters.
     */
    "postal_code"?: string;
    /**
     * Properties for this account.
     */
    "account_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * An array of aliases, not more than 10. An alias is not shorter than 8 and not longer than 100 characters.
     */
    "aliases"?: Array<string>;
    /**
     * Postal address line 2, not longer than 100 characters.
     */
    "address_line2"?: string;
    /**
     * The city part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "city"?: string;
    /**
     * Postal address line 1, not longer than 100 characters. Required for commercial accounts only.
     */
    "address_line1"?: string;
    /**
     * The display name for the account, not longer than 100 characters.
     */
    "display_name"?: string;
    /**
     * The enforcement status of setting up the multi-factor authentication. 'Enforced' means that setting up the MFA is required after login. 'Optional' means that the MFA is not required.
     */
    "mfa_status"?: AccountUpdateRootReq.MfaStatusEnum;
    /**
     * The state part of the postal address, not longer than 100 characters.
     */
    "state"?: string;
    /**
     * Contract number of the customer.
     */
    "contract_number"?: string;
    /**
     * The phone number of a representative of the company, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * The name of the company, not longer than 100 characters. Required for commercial accounts only.
     */
    "company"?: string;
    /**
     * The reference token expiration time in minutes for this account. Between 1 and 120 minutes.
     */
    "idle_timeout"?: string;
    /**
     * The country part of the postal address, not longer than 100 characters. Required for commercial accounts only.
     */
    "country"?: string;
    /**
     * Customer number of the customer.
     */
    "customer_number"?: string;
    /**
     * Indicates how many days before account expiration a notification email should be sent. Valid values are: 1-180.
     */
    "expiration_warning_threshold"?: string;
    /**
     * The name of the contact person for this account, not longer than 100 characters. Required for commercial accounts only.
     */
    "contact"?: string;
    /**
     * A list of notification email addresses.
     */
    "notification_emails"?: Array<string>;
}

/**
 * This object represents an active user session.
 */
export namespace ActiveSession {
    export type ObjectEnum = "user-session";
}
export interface ActiveSession {
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * Entity name: always 'user-session'
     */
    "object": ActiveSession.ObjectEnum;
    /**
     * User Agent header from the login request.
     */
    "user_agent": string;
    /**
     * IP address of the client.
     */
    "ip_address": string;
    /**
     * The reference token.
     */
    "reference_token": string;
    /**
     * The login time of the user.
     */
    "login_time": Date;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface AdminUserUpdateReq {
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
    /**
     * A list of group IDs this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has to be enabled or disabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * Users notification properties for root admins. Currently supported; 'agreement_acceptance_notification', which controls whether notification should be sent upon accepting an agreement in an account. Possible values are: 'always_notify', 'only_first' and 'not_interested'.
     */
    "notification_properties"?: { [key: string]: string; };
    /**
     * The status of the user.
     */
    "status"?: string;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address, not longer than 254 characters.
     */
    "email"?: string;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export namespace ApiKeyInfoReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface ApiKeyInfoReq {
    /**
     * The owner of this API key.
     */
    "owner"?: string;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoReq.StatusEnum;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
}

/**
 * This object represents an API key in mbed Cloud.
 */
export namespace ApiKeyInfoResp {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ObjectEnum = "api-key";
}
export interface ApiKeyInfoResp {
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyInfoResp.StatusEnum;
    /**
     * The display name for the API key.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'api-key'
     */
    "object": ApiKeyInfoResp.ObjectEnum;
    /**
     * The timestamp of the API key creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The API key.
     */
    "key": string;
    /**
     * The owner of this API key, who is the creator by default.
     */
    "owner"?: string;
    /**
     * The UUID of the API key.
     */
    "id": string;
    /**
     * The timestamp of the latest API key usage, in milliseconds.
     */
    "last_login_time"?: number;
}

export namespace ApiKeyInfoRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface ApiKeyInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": ApiKeyInfoRespList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<ApiKeyInfoResp>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: ApiKeyInfoRespList.OrderEnum;
}

/**
 * This object represents an API key in requests towards mbed Cloud.
 */
export namespace ApiKeyUpdateReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface ApiKeyUpdateReq {
    /**
     * The owner of this API key.
     */
    "owner"?: string;
    /**
     * The status of the API key.
     */
    "status"?: ApiKeyUpdateReq.StatusEnum;
    /**
     * The display name for the API key, not longer than 100 characters.
     */
    "name": string;
    /**
     * A list of group IDs this API key belongs to.
     */
    "groups"?: Array<string>;
}

/**
 * This object represents an error message.
 */
export namespace ErrorResponse {
    export type ObjectEnum = "error";
    export type TypeEnum = "success" | "created" | "accepted" | "permanently_deleted" | "validation_error" | "invalid_token" | "invalid_apikey" | "reauth_required" | "access_denied" | "account_limit_exceeded" | "not_found" | "method_not_supported" | "not_acceptable" | "duplicate" | "precondition_failed" | "unsupported_media_type" | "rate_limit_exceeded" | "internal_server_error" | "system_unavailable";
}
export interface ErrorResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Failed input fields during request object validation.
     */
    "fields"?: Array<Field>;
    /**
     * Entity name, always 'error'.
     */
    "object": ErrorResponse.ObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Error type.
     */
    "type": ErrorResponse.TypeEnum;
}

/**
 * This object represents a feature policy. Either the feature or the resource must be specified.
 */
export interface FeaturePolicy {
    /**
     * Comma separated list of actions, empty string represents all actions.
     */
    "action"?: string;
    /**
     * Resource that is protected by this policy.
     */
    "resource"?: string;
    /**
     * Feature name corresponding to this policy.
     */
    "feature"?: string;
    /**
     * True or false controlling whether an action is allowed or not.
     */
    "allow"?: boolean;
    /**
     * Flag indicating whether this feature is inherited or overwritten specifically.
     */
    "inherited"?: boolean;
}

export interface Field {
    /**
     * Message describing the erroneous situation.
     */
    "message": string;
    /**
     * Name of the erroneous field.
     */
    "name": string;
}

/**
 * This object is used when creating new groups.
 */
export interface GroupCreationInfo {
    /**
     * The group name, not longer than 100 characters.
     */
    "name": string;
    /**
     * The members of the group as arrays of user and API key UUIDs.
     */
    "members"?: SubjectList;
}

/**
 * This object contains basic information about groups.
 */
export namespace GroupSummary {
    export type ObjectEnum = "group";
}
export interface GroupSummary {
    /**
     * The number of users in this group.
     */
    "user_count": number;
    /**
     * The UUID of the account this group belongs to.
     */
    "account_id": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'group'
     */
    "object": GroupSummary.ObjectEnum;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The number of API keys in this group.
     */
    "apikey_count": number;
    /**
     * The UUID of the group.
     */
    "id": string;
    /**
     * The name of the group.
     */
    "name": string;
}

export namespace GroupSummaryList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface GroupSummaryList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": GroupSummaryList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<GroupSummary>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: GroupSummaryList.OrderEnum;
}

/**
 * This object is used when updating groups.
 */
export interface GroupUpdateInfo {
    /**
     * The group name, not longer than 100 characters.
     */
    "name": string;
}

/**
 * This object represents an entry in login history.
 */
export interface LoginHistory {
    /**
     * UTC time RFC3339 for this login attempt.
     */
    "date": Date;
    /**
     * IP address of the client.
     */
    "ip_address": string;
    /**
     * User Agent header from the login request.
     */
    "user_agent": string;
    /**
     * Flag indicating whether login attempt was successful or not.
     */
    "success": boolean;
}

/**
 * This object represents user details.
 */
export namespace MyUserInfoResp {
    export type StatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
    export type ObjectEnum = "user";
}
export interface MyUserInfoResp {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
    /**
     * List of active user sessions.
     */
    "active_sessions"?: Array<ActiveSession>;
    /**
     * Timestamps, succeedings, IP addresses and user agent information of the last five logins of the user, with timestamps in RFC3339 format.
     */
    "login_history"?: Array<LoginHistory>;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The email address.
     */
    "email": string;
    /**
     * The status of the user. ENROLLING state indicates that the user is in the middle of the enrollment process. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately. INACTIVE users are locked out and not permitted to use the system.
     */
    "status": MyUserInfoResp.StatusEnum;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A list of scratch codes for the 2-factor authentication. Visible only when 2FA is requested to be enabled or the codes regenerated.
     */
    "totp_scratch_codes"?: Array<string>;
    /**
     * Entity name: always 'user'
     */
    "object": MyUserInfoResp.ObjectEnum;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has been enabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
}

export interface PasswordPolicy {
    /**
     * Minimum length for the password. A number between 8 and 512.
     */
    "minimum_length": string;
}

/**
 * This object is used while creating new policies.
 */
export namespace PolicyCreationReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface PolicyCreationReq {
    /**
     * The status of this policy.
     */
    "status"?: PolicyCreationReq.StatusEnum;
    /**
     * Specifies the date and time until the policy is valid in UTC time RFC3339. E.g. '2018-02-05T09:43:44Z'
     */
    "valid_until"?: Date;
    /**
     * Specifies the value in seconds for how long an authorization result is valid.
     */
    "grant_expires_in"?: number;
    /**
     * The name of this policy, must be unique and not longer than 100 character.
     */
    "name": string;
    /**
     * Custom error message returned when this policy matches with not allowed result.
     */
    "error_message"?: string;
    /**
     * List of not_resources in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100.
     */
    "not_resources"?: Array<string>;
    /**
     * List of actions as key-pairs of '{action}': 'true' or 'false', not more than 100. For enabling all actions use { '*': true }.
     */
    "actions"?: { [key: string]: boolean; };
    /**
     * List of not_conditions in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100.
     */
    "not_conditions"?: Array<string>;
    /**
     * Specifies the date and time when the policy will become valid in UTC time RFC3339. E.g. '2018-02-05T09:43:44Z'
     */
    "valid_from"?: Date;
    /**
     * List of user IDs this policy is attached to, not more than 100.
     */
    "users"?: Array<string>;
    /**
     * List of group IDs this policy is attached to, not more than 100.
     */
    "groups"?: Array<string>;
    /**
     * Policy tag that can be used for various purposes to be able to distinguish between policies. Not longer than 100 characters.
     */
    "tag"?: string;
    /**
     * List of not_actions, not more than 100.
     */
    "notActions"?: Array<string>;
    /**
     * List of API key IDs this policy is attached to, not more than 100.
     */
    "apikeys"?: Array<string>;
    /**
     * List of conditions in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100.
     */
    "conditions"?: Array<string>;
    /**
     * List of resources in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100.
     */
    "resources"?: Array<string>;
    /**
     * The description of this policy, not longer than 500 character.
     */
    "description"?: string;
}

/**
 * This object represents a policy in responses.
 */
export namespace PolicyInfo {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ObjectEnum = "policy";
}
export interface PolicyInfo {
    /**
     * Specifies the date and time until the policy is valid.
     */
    "valid_until"?: Date;
    /**
     * Specifies the value in seconds for how long an authorization result is valid.
     */
    "grant_expires_in"?: number;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at": Date;
    /**
     * List of actions.
     */
    "actions": { [key: string]: boolean; };
    /**
     * Policy tag that can be used for various purposes to be able to distinguish between policies.
     */
    "tag"?: string;
    /**
     * List of API key IDs this policy is attached to.
     */
    "apikeys"?: Array<string>;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * List of user IDs this policy is attached to.
     */
    "users"?: Array<string>;
    /**
     * Specifies the date and time when the policy will become valid.
     */
    "valid_from"?: Date;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * List of conditions.
     */
    "conditions": Array<string>;
    /**
     * List of resources.
     */
    "resources": Array<string>;
    /**
     * The status of this policy.
     */
    "status": PolicyInfo.StatusEnum;
    /**
     * The description of this policy.
     */
    "description"?: string;
    /**
     * Entity name: always 'policy'
     */
    "object": PolicyInfo.ObjectEnum;
    /**
     * List of group IDs this policy is attached to.
     */
    "groups"?: Array<string>;
    /**
     * List of not_actions.
     */
    "notActions": Array<string>;
    /**
     * List of not_resources.
     */
    "notResources": Array<string>;
    /**
     * The name of this policy.
     */
    "name": string;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Custom error message returned when this policy matches with not allowed result.
     */
    "error_message"?: string;
    /**
     * List of not_conditions.
     */
    "notConditions": Array<string>;
}

export namespace PolicyInfoList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface PolicyInfoList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": PolicyInfoList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<PolicyInfo>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: PolicyInfoList.OrderEnum;
}

/**
 * This object is used while creating new policies.
 */
export namespace PolicyUpdateReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
}
export interface PolicyUpdateReq {
    /**
     * The new status of this policy.
     */
    "status"?: PolicyUpdateReq.StatusEnum;
    /**
     * Specifies the date and time until the policy is valid in UTC time RFC3339. E.g. '2018-02-05T09:43:44Z'
     */
    "valid_until"?: Date;
    /**
     * Specifies the value in seconds for how long an authorization result is valid.
     */
    "grant_expires_in"?: number;
    /**
     * The new name of this policy, must be unique and not longer than 100 character.
     */
    "name"?: string;
    /**
     * Custom error message returned when this policy matches with not allowed result.
     */
    "error_message"?: string;
    /**
     * New list of not_resources in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100. Previous list will be overwritten.
     */
    "not_resources"?: Array<string>;
    /**
     * New list of actions as key-pairs of '{action}': 'true' or 'false', not more than 100. For enabling all actions use { '*': true }. Previous list will be overwritten.
     */
    "actions"?: { [key: string]: boolean; };
    /**
     * New list of not_conditions in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100. Previous list will be overwritten.
     */
    "not_conditions"?: Array<string>;
    /**
     * Specifies the date and time when the policy will become valid in UTC time RFC3339. E.g. '2018-02-05T09:43:44Z'
     */
    "valid_from"?: Date;
    /**
     * New list of user IDs this policy is attached to, not more than 100. Previous list will be overwritten.
     */
    "users"?: Array<string>;
    /**
     * New list of group IDs this policy is attached to, not more than 100. Previous list will be overwritten.
     */
    "groups"?: Array<string>;
    /**
     * New policy tag that can be used for various purposes to be able to distinguish between policies. Not longer than 100 characters.
     */
    "tag"?: string;
    /**
     * New list of not_actions, not more than 100. Previous list will be overwritten.
     */
    "notActions"?: Array<string>;
    /**
     * New list of API key IDs this policy is attached to, not more than 100. Previous list will be overwritten.
     */
    "apikeys"?: Array<string>;
    /**
     * New list of conditions in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100. Previous list will be overwritten.
     */
    "conditions"?: Array<string>;
    /**
     * New list of resources in urn:mbed-cloud:{resource-type}:{resource-name} format, not more than 100. Previous list will be overwritten.
     */
    "resources"?: Array<string>;
    /**
     * The new description of this policy, not longer than 500 character.
     */
    "description"?: string;
}

/**
 * This object represents arrays of user and API key IDs.
 */
export interface SubjectList {
    /**
     * An array of API key IDs.
     */
    "apikeys"?: Array<string>;
    /**
     * An array of user IDs.
     */
    "users"?: Array<string>;
}

/**
 * This object represents a trusted certificate in responses.
 */
export namespace TrustedCertificateInternalResp {
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ObjectEnum = "trusted-cert";
}
export interface TrustedCertificateInternalResp {
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateInternalResp.ServiceEnum;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateInternalResp.StatusEnum;
    /**
     * Private key of the certificate in PEM or base64 encoded DER format.
     */
    "private_key": string;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * If true, signature is not required. Default value false.
     */
    "enrollment_mode"?: boolean;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode"?: number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateInternalResp.ObjectEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": Date;
    /**
     * The UUID of the owner.
     */
    "owner_id"?: string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
}

export namespace TrustedCertificateInternalRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface TrustedCertificateInternalRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateInternalRespList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateInternalResp>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateInternalRespList.OrderEnum;
}

/**
 * This object represents a trusted certificate in upload requests.
 */
export namespace TrustedCertificateReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ServiceEnum = "lwm2m" | "bootstrap";
}
export interface TrustedCertificateReq {
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateReq.StatusEnum;
    /**
     * If true, signature parameter is not required. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * X509.v3 trusted certificate in PEM format. Chaining multiple certificates after one another is supported.
     */
    "certificate": string;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateReq.ServiceEnum;
    /**
     * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256. Optional if enrollment_mode is 'true'.
     */
    "signature"?: string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
}

/**
 * This object represents a trusted certificate in responses.
 */
export namespace TrustedCertificateResp {
    export type ServiceEnum = "lwm2m" | "bootstrap";
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ObjectEnum = "trusted-cert";
}
export interface TrustedCertificateResp {
    /**
     * Service name where the certificate is to be used.
     */
    "service": TrustedCertificateResp.ServiceEnum;
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateResp.StatusEnum;
    /**
     * Certificate name.
     */
    "name": string;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate": string;
    /**
     * If true, signature is not required. Default value false.
     */
    "enrollment_mode"?: boolean;
    /**
     * Issuer of the certificate.
     */
    "issuer": string;
    /**
     * Device execution mode where 1 means a developer certificate.
     */
    "device_execution_mode"?: number;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * Entity name: always 'trusted-cert'
     */
    "object": TrustedCertificateResp.ObjectEnum;
    /**
     * Subject of the certificate.
     */
    "subject": string;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * Expiration time in UTC formatted as RFC3339.
     */
    "validity": Date;
    /**
     * The UUID of the owner.
     */
    "owner_id"?: string;
    /**
     * Entity ID.
     */
    "id": string;
    /**
     * Human readable description of this certificate.
     */
    "description"?: string;
}

export namespace TrustedCertificateRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface TrustedCertificateRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": TrustedCertificateRespList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<TrustedCertificateResp>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: TrustedCertificateRespList.OrderEnum;
}

/**
 * This object represents a trusted certificate in upload requests.
 */
export namespace TrustedCertificateRootReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ServiceEnum = "lwm2m" | "bootstrap";
}
export interface TrustedCertificateRootReq {
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateRootReq.StatusEnum;
    /**
     * If true, signature parameter is not required. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * X509.v3 trusted certificate in PEM format. Chaining multiple certificates after one another is supported.
     */
    "certificate": string;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name": string;
    /**
     * Service name where the certificate must be used.
     */
    "service": TrustedCertificateRootReq.ServiceEnum;
    /**
     * Base64 encoded signature of the account ID signed by the certificate to be uploaded. Signature must be hashed with SHA256. Optional if enrollment_mode is 'true'.
     */
    "signature"?: string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
}

/**
 * This object represents a trusted certificate in update requests.
 */
export namespace TrustedCertificateUpdateReq {
    export type StatusEnum = "ACTIVE" | "INACTIVE";
    export type ServiceEnum = "lwm2m" | "bootstrap";
}
export interface TrustedCertificateUpdateReq {
    /**
     * Status of the certificate.
     */
    "status"?: TrustedCertificateUpdateReq.StatusEnum;
    /**
     * If true, signature parameter is not required. Default value is false.
     */
    "enrollment_mode"?: boolean;
    /**
     * X509.v3 trusted certificate in PEM format.
     */
    "certificate"?: string;
    /**
     * Certificate name, not longer than 100 characters.
     */
    "name"?: string;
    /**
     * Service name where the certificate must be used.
     */
    "service"?: TrustedCertificateUpdateReq.ServiceEnum;
    /**
     * Base64 encoded signature of the account ID signed by the certificate whose data to be updated. Signature must be hashed with SHA256.
     */
    "signature"?: string;
    /**
     * Human readable description of this certificate, not longer than 500 characters.
     */
    "description"?: string;
}

/**
 * This object represents a response to an update request.
 */
export namespace UpdatedResponse {
    export type ObjectEnum = "user" | "api-key" | "group" | "account" | "account-template" | "trusted-cert" | "list" | "error" | "policy" | "identity-provider" | "user-session";
    export type TypeEnum = "success";
}
export interface UpdatedResponse {
    /**
     * Response code.
     */
    "code": number;
    /**
     * Entity name: 'user', 'apikey', 'group', 'policy' or 'account'.
     */
    "object": UpdatedResponse.ObjectEnum;
    /**
     * Request ID.
     */
    "request_id": string;
    /**
     * A human readable message with detailed info.
     */
    "message": string;
    /**
     * Response type: success.
     */
    "type": UpdatedResponse.TypeEnum;
    /**
     * Entity ID.
     */
    "id": string;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserInfoReq {
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address, not longer than 254 characters.
     */
    "email": string;
}

/**
 * This object represents a user in mbed Cloud.
 */
export namespace UserInfoResp {
    export type StatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
    export type ObjectEnum = "user";
}
export interface UserInfoResp {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
    /**
     * Timestamps, succeedings, IP addresses and user agent information of the last five logins of the user, with timestamps in RFC3339 format.
     */
    "login_history"?: Array<LoginHistory>;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The email address.
     */
    "email": string;
    /**
     * The status of the user. ENROLLING state indicates that the user is in the middle of the enrollment process. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately. INACTIVE users are locked out and not permitted to use the system.
     */
    "status": UserInfoResp.StatusEnum;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * Entity name: always 'user'
     */
    "object": UserInfoResp.ObjectEnum;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has been enabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
}

export namespace UserInfoRespList {
    export type ObjectEnum = "list";
    export type OrderEnum = "ASC" | "DESC";
}
export interface UserInfoRespList {
    /**
     * The entity ID to fetch after the given one.
     */
    "after"?: string;
    /**
     * Flag indicating whether there is more results.
     */
    "has_more": boolean;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count": number;
    /**
     * Entity name: always 'list'
     */
    "object": UserInfoRespList.ObjectEnum;
    /**
     * The number of results to return, (range: 2-1000), or equals to `total_count`
     */
    "limit": number;
    /**
     * A list of entities.
     */
    "data": Array<UserInfoResp>;
    /**
     * The order of the records to return based on creation time. Available values: ASC, DESC; by default ASC.
     */
    "order"?: UserInfoRespList.OrderEnum;
}

/**
 * This object represents a user in requests towards mbed Cloud.
 */
export interface UserUpdateReq {
    /**
     * Phone number, not longer than 100 characters.
     */
    "phone_number"?: string;
    /**
     * A username containing alphanumerical letters and -,._@+= characters. It must be at least 4 but not more than 30 character long.
     */
    "username"?: string;
    /**
     * A list of group IDs this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has to be enabled or disabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * The status of the user.
     */
    "status"?: string;
    /**
     * The full name of the user, not longer than 100 characters.
     */
    "full_name"?: string;
    /**
     * Address, not longer than 100 characters.
     */
    "address"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * The email address, not longer than 254 characters.
     */
    "email"?: string;
}

/**
 * This object represents a user update response.
 */
export namespace UserUpdateResp {
    export type StatusEnum = "ENROLLING" | "INVITED" | "ACTIVE" | "RESET" | "INACTIVE";
    export type ObjectEnum = "user";
}
export interface UserUpdateResp {
    /**
     * A username containing alphanumerical letters and -,._@+= characters.
     */
    "username"?: string;
    /**
     * List of active user sessions.
     */
    "active_sessions"?: Array<ActiveSession>;
    /**
     * Timestamps, succeedings, IP addresses and user agent information of the last five logins of the user, with timestamps in RFC3339 format.
     */
    "login_history"?: Array<LoginHistory>;
    /**
     * A timestamp of the user creation in the storage, in milliseconds.
     */
    "creation_time"?: number;
    /**
     * Last update UTC time RFC3339.
     */
    "updated_at"?: Date;
    /**
     * The full name of the user.
     */
    "full_name"?: string;
    /**
     * The UUID of the user.
     */
    "id": string;
    /**
     * A timestamp of the latest login of the user, in milliseconds.
     */
    "last_login_time"?: number;
    /**
     * A flag indicating that the General Terms and Conditions has been accepted.
     */
    "is_gtc_accepted"?: boolean;
    /**
     * API resource entity version.
     */
    "etag": string;
    /**
     * A flag indicating that receiving marketing information has been accepted.
     */
    "is_marketing_accepted"?: boolean;
    /**
     * Phone number.
     */
    "phone_number"?: string;
    /**
     * The email address.
     */
    "email": string;
    /**
     * The status of the user. ENROLLING state indicates that the user is in the middle of the enrollment process. INVITED means that the user has not accepted the invitation request. RESET means that the password must be changed immediately. INACTIVE users are locked out and not permitted to use the system.
     */
    "status": UserUpdateResp.StatusEnum;
    /**
     * The UUID of the account.
     */
    "account_id": string;
    /**
     * A list of scratch codes for the 2-factor authentication. Visible only when 2FA is requested to be enabled or the codes regenerated.
     */
    "totp_scratch_codes"?: Array<string>;
    /**
     * Entity name: always 'user'
     */
    "object": UserUpdateResp.ObjectEnum;
    /**
     * A list of IDs of the groups this user belongs to.
     */
    "groups"?: Array<string>;
    /**
     * Address.
     */
    "address"?: string;
    /**
     * Secret for the 2-factor authenticator app. Visible only when 2FA is requested to be enabled.
     */
    "totp_secret"?: string;
    /**
     * The password when creating a new user. It will be generated when not present in the request.
     */
    "password"?: string;
    /**
     * A flag indicating whether the user's email address has been verified or not.
     */
    "email_verified"?: boolean;
    /**
     * Creation UTC time RFC3339.
     */
    "created_at"?: Date;
    /**
     * User's account specific custom properties.
     */
    "user_properties"?: { [key: string]: { [key: string]: string; }; };
    /**
     * A flag indicating whether 2-factor authentication (TOTP) has been enabled.
     */
    "is_totp_enabled"?: boolean;
    /**
     * A timestamp of the latest change of the user password, in milliseconds.
     */
    "password_changed_time"?: number;
}

/**
 * AccountAdminApi
 */
export class AccountAdminApi extends ApiBase {

    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.
     * @param apiKey The ID of the API key to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addApiKeyToGroups(apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Upload a new trusted certificate.
     * An endpoint for uploading new trusted certificates.
     * @param body A trusted certificate object with attributes.
     */
    public addCertificate(body: TrustedCertificateReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add members to a group.
     * An endpoint for adding users and API keys to groups.
     * @param groupID The ID of the group to be updated.
     * @param body A list of users and API keys to be added to the group.
     */
    public addSubjectsToGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add user to a list of groups.
     * An endpoint for adding user to groups.
     * @param userId The ID of the user to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addUserToGroups(userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new group.
     * An endpoint for creating a new group.
     * @param body Details of the group to be created.
     */
    public createGroup(body: GroupCreationInfo, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/policy-groups",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new user.
     * An endpoint for creating or inviting a new user to the account. In case of invitation email address is used only, other attributes are set in the 2nd step.
     * @param body A user object with attributes.
     * @param action Action, either &#39;create&#39; or &#39;invite&#39;.
     */
    public createUser(body: UserInfoReq, action?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete a group.
     * An endpoint for deleting a group.
     * @param groupID The ID of the group to be deleted.
     */
    public deleteGroup(groupID: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.
     * @param userId The ID of the user to be deleted.
     */
    public deleteUser(userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get the details of all users.
     * An endpoint for retrieving the details of all users.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param emailEq Filter for email address
     * @param statusEq Filter for status, for example active or reset
     */
    public getAllUsers(limit?: number, after?: string, order?: string, include?: string, emailEq?: string, statusEq?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (emailEq !== undefined) {
            queryParameters["email__eq"] = emailEq;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/users",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.
     * @param apiKey The ID of the API key whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfApikey(apiKey: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the user.
     * An endpoint for retrieving groups of the user.
     * @param userId The ID of the user whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfUser(userId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Details of a user.
     * An endpoint for retrieving the details of a user.
     * @param userId The ID of the user whose details are retrieved.
     * @param properties Request to return account specific user property values according to the given property name.
     */
    public getUser(userId: string, properties?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get users of a group.
     * An endpoint for listing the users of a group with details.
     * @param groupID The ID of the group whose users are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getUsersOfGroup(groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/policy-groups/{groupID}/users".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.
     * @param apiKey The ID of the API key to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeApiKeyFromGroups(apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/{apiKey}/groups".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove user from groups.
     * An endpoint for removing user from groups.
     * @param userId The ID of the user to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeUserFromGroups(userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/{user-id}/groups".replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove users from a group.
     * An endpoint for removing users from groups.
     * @param groupID The ID of the group whose users are removed.
     * @param body A list of users to be removed from the group.
     */
    public removeUsersFromGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}/users".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update the group name.
     * An endpoint for updating a group name.
     * @param groupID The ID of the group to be updated.
     * @param body Details of the group to be created.
     */
    public updateGroupName(groupID: string, body: GroupUpdateInfo, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Updates attributes of the account.
     * An endpoint for updating the account.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/accounts/me -d &#39;{\&quot;phone_number\&quot;: \&quot;12345678\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body Details of the account to be updated.
     */
    public updateMyAccount(body: AccountUpdateReq, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/me",
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update user details.
     * An endpoint for updating user details.
     * @param userId The ID of the user whose details are updated.
     * @param body A user object with attributes.
     */
    public updateUser(userId: string, body: UserUpdateReq, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/users/{user-id}".replace("{" + "user-id" + "}", String(userId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
}
/**
 * AggregatorAccountAdminApi
 */
export class AggregatorAccountAdminApi extends ApiBase {

    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addAccountApiKeyToGroups(accountID: string, apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Upload new trusted certificate.
     * An endpoint for uploading new trusted certificates.
     * @param accountID Account ID.
     * @param body A trusted certificate object with attributes, signature is optional.
     */
    public addAccountCertificate(accountID: string, body: TrustedCertificateRootReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add user to a list of groups.
     * An endpoint for adding user to groups.
     * @param accountID Account ID.
     * @param userId The ID of the user to be added to the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public addAccountUserToGroups(accountID: string, userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add members to a group.
     * An endpoint for adding users and API keys to groups.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be updated.
     * @param body A list of users and API keys to be added to the group.
     */
    public addSubjectsToAccountGroup(accountID: string, groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Attach a policy to API keys.
     * An endpoint for attaching policy to API keys.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be attached to API keys.
     * @param body List of API key IDs.
     */
    public attachAccountPolicyToApikeys(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Attach a policy to groups.
     * An endpoint for attaching policy to groups.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be attached to groups.
     * @param body List of groups IDs.
     */
    public attachAccountPolicyToGroup(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Attach a policy to users.
     * An endpoint for attaching policy to users.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be attached to users.
     * @param body List of user IDs.
     */
    public attachAccountPolicyToUsers(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Check the API key.
     * An endpoint for checking API key.
     * @param accountID Account ID.
     * @param apiKey The API key to be checked.
     */
    public checkAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Create a new account.
     * An endpoint for creating a new account.
     * @param body Details of the account to be created.
     * @param action Action, either &#39;create&#39;, &#39;enroll&#39; or &#39;enrollment_link&#39;.
     */
    public createAccount(body: AccountCreationReq, action?: string, callback?: (error: any, data?: AccountCreationResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountCreationResp>({
            url: "/v3/accounts",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key. There is no default value for the owner ID and it must be from the same account where the new API key is created.
     * @param accountID Account ID.
     * @param body Details of the API key to be created.
     */
    public createAccountApiKey(accountID: string, body: ApiKeyInfoReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a policy.
     * An endpoint for creating a new policy.
     * @param accountID Account ID.
     * @param body The details of the policy to be created.
     */
    public createAccountPolicy(accountID: string, body: PolicyCreationReq, callback?: (error: any, data?: PolicyInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<PolicyInfo>({
            url: "/v3/accounts/{accountID}/policies".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new user.
     * An endpoint for creating or inviting a new user to the account. In case of invitation email address is used only, other attributes are set in the 2nd step.
     * @param accountID Account ID.
     * @param body A user object with attributes.
     * @param action Create or invite user.
     */
    public createAccountUser(accountID: string, body: UserInfoReq, action?: string, callback?: (error: any, data?: UserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (action !== undefined) {
            queryParameters["action"] = action;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoResp>({
            url: "/v3/accounts/{accountID}/users".replace("{" + "accountID" + "}", String(accountID)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete the API key.
     * An endpoint for deleting an API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete trusted certificate by ID.
     * An endpoint for deleting the trusted certificate.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be deleted.
     */
    public deleteAccountCertificate(accountID: string, certId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete policy.
     * An endpoint for deleting a policy.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be deleted.
     */
    public deleteAccountPolicy(accountID: string, policyId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a user.
     * An endpoint for deleting a user.
     * @param accountID Account ID.
     * @param userId The ID of the user to be deleted.
     */
    public deleteAccountUser(accountID: string, userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Detach a policy from API keys.
     * An endpoint for detaching policy from API keys.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be detached from API keys.
     * @param body List of API key IDs.
     */
    public detachAccountPolicyFromApikeys(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Detach a policy from users.
     * An endpoint for detaching policy from users.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be detached from users.
     * @param body List of user IDs.
     */
    public detachAccountPolicyFromUsers(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Detach a policy to groups.
     * An endpoint for detaching policy to groups.
     * @param accountID Account ID.
     * @param policyId The ID of the policy to be detached from groups.
     * @param body List of groups IDs.
     */
    public detachAccountPolicyToGroup(accountID: string, policyId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getAccountApiKey(accountID: string, apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be retrieved.
     */
    public getAccountCertificate(accountID: string, certId: string, callback?: (error: any, data?: TrustedCertificateInternalResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get group information.
     * An endpoint for getting general information about the group.
     * @param accountID Account ID.
     * @param groupID The ID of the group to be retrieved.
     */
    public getAccountGroupSummary(accountID: string, groupID: string, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get account info.
     * Returns detailed information about the account.
     * @param accountID The ID of the account to be fetched.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     * @param properties Property name to be returned from account specific properties.
     */
    public getAccountInfo(accountID: string, include?: string, properties?: string, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/{accountID}".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get policy by ID.
     * An endpoint for retrieving a policy by ID.
     * @param accountID Account ID.
     * @param policyId The ID the policy to be retrieved.
     */
    public getAccountPolicy(accountID: string, policyId: string, callback?: (error: any, data?: PolicyInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<PolicyInfo>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Fetch details of policy&#39;s API keys.
     * An endpoint for fetching detailed information about API keys this policy is attached to.
     * @param accountID Account ID.
     * @param policyId The ID the policy whose API keys to be retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getAccountPolicyApikeys(accountID: string, policyId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Fetch details of policy&#39;s groups.
     * An endpoint for fetching detailed information about groups this policy is attached to.
     * @param accountID Account ID.
     * @param policyId The ID the policy whose API keys to be retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getAccountPolicyGroups(accountID: string, policyId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Fetch details of policy&#39;s users.
     * An endpoint for fetching detailed information about users this policy is attached to.
     * @param accountID Account ID.
     * @param policyId The ID the policy whose users to be retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getAccountPolicyUsers(accountID: string, policyId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Details of the user.
     * An endpoint for retrieving details of the user.
     * @param accountID Account ID.
     * @param userId The ID of the user to be retrieved.
     * @param scratchCodes Request to regenerate new emergency scratch codes.
     * @param properties Request to return account specific user property values according to the given property name.
     */
    public getAccountUser(accountID: string, userId: string, scratchCodes?: string, properties?: string, callback?: (error: any, data?: MyUserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (scratchCodes !== undefined) {
            queryParameters["scratch_codes"] = scratchCodes;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<MyUserInfoResp>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all API keys.
     * An endpoint for retrieving the API keys in an array, optionally filtered by the owner.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param keyEq API key filter.
     * @param ownerEq Owner name filter.
     */
    public getAllAccountApiKeys(accountID: string, limit?: number, after?: string, order?: string, include?: string, keyEq?: string, ownerEq?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (keyEq !== undefined) {
            queryParameters["key__eq"] = keyEq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/accounts/{accountID}/api-keys".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for certificate name
     * @param serviceEq Filter for service
     * @param expireEq Filter for expire
     * @param deviceExecutionModeEq Filter for developer certificates
     * @param deviceExecutionModeNeq Filter for not developer certificates
     * @param ownerEq Owner name filter
     * @param enrollmentModeEq Enrollment mode filter
     * @param issuerLike Filter for issuer. Finds all matches where the filter value is a case insensitive substring of the result. Example: issuer__like&#x3D;cn&#x3D;iss matches CN&#x3D;issuer.
     * @param subjectLike Filter for subject. Finds all matches where the filter value is a case insensitive substring of the result. Example: subject__like&#x3D;cn&#x3D;su matches CN&#x3D;subject.
     */
    public getAllAccountCertificates(accountID: string, limit?: number, after?: string, order?: string, include?: string, nameEq?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, deviceExecutionModeNeq?: number, ownerEq?: string, enrollmentModeEq?: boolean, issuerLike?: string, subjectLike?: string, callback?: (error: any, data?: TrustedCertificateInternalRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }
        if (serviceEq !== undefined) {
            queryParameters["service__eq"] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters["expire__eq"] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters["device_execution_mode__eq"] = deviceExecutionModeEq;
        }
        if (deviceExecutionModeNeq !== undefined) {
            queryParameters["device_execution_mode__neq"] = deviceExecutionModeNeq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }
        if (enrollmentModeEq !== undefined) {
            queryParameters["enrollment_mode__eq"] = enrollmentModeEq;
        }
        if (issuerLike !== undefined) {
            queryParameters["issuer__like"] = issuerLike;
        }
        if (subjectLike !== undefined) {
            queryParameters["subject__like"] = subjectLike;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalRespList>({
            url: "/v3/accounts/{accountID}/trusted-certificates".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for group name
     */
    public getAllAccountGroups(accountID: string, limit?: number, after?: string, order?: string, include?: string, nameEq?: string, callback?: (error: any, data?: Array<GroupSummary>, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<Array<GroupSummary>>({
            url: "/v3/accounts/{accountID}/policy-groups".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all policies.
     * An endpoint for retrieving all policies in the account.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param nameEq Filter result by policy name.
     * @param statusEq Filter for status, ACTIVE or INACTIVE.
     * @param tagEq Filter results for tag.
     * @param userIdEq Retrieve policies attached to a certain user ID.
     * @param apikeyIdEq Retrieve policies attached to a certain API key ID.
     * @param groupIdEq Retrieve policies attached to a certain group ID.
     * @param unbounded Retrieve policies not attached to any subject in the account.
     */
    public getAllAccountPolicies(accountID: string, limit?: number, after?: string, order?: string, nameEq?: string, statusEq?: string, tagEq?: string, userIdEq?: string, apikeyIdEq?: string, groupIdEq?: string, unbounded?: string, callback?: (error: any, data?: PolicyInfoList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (tagEq !== undefined) {
            queryParameters["tag__eq"] = tagEq;
        }
        if (userIdEq !== undefined) {
            queryParameters["user_id__eq"] = userIdEq;
        }
        if (apikeyIdEq !== undefined) {
            queryParameters["apikey_id__eq"] = apikeyIdEq;
        }
        if (groupIdEq !== undefined) {
            queryParameters["group_id__eq"] = groupIdEq;
        }
        if (unbounded !== undefined) {
            queryParameters["unbounded"] = unbounded;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<PolicyInfoList>({
            url: "/v3/accounts/{accountID}/policies".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all user details.
     * An endpoint for retrieving details of all users.
     * @param accountID Account ID.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param emailEq Filter for email address
     * @param statusEq Filter for status
     */
    public getAllAccountUsers(accountID: string, limit?: number, after?: string, order?: string, include?: string, emailEq?: string, statusEq?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (emailEq !== undefined) {
            queryParameters["email__eq"] = emailEq;
        }
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/accounts/{accountID}/users".replace("{" + "accountID" + "}", String(accountID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all accounts.
     * Returns an array of account objects, optionally filtered by status and tier level.
     * @param statusEq An optional filter for account status, ENROLLING, ACTIVE, RESTRICTED or SUSPENDED.
     * @param tierEq An optional filter for tier level, must be 0, 1, 2, 98, 99 or omitted.
     * @param parentEq An optional filter for parent account ID.
     * @param endMarketEq An optional filter for account end market.
     * @param countryLike An optional filter for account country. Finds all matches where the filter value is a case insensitive substring of the result. Example: country__like&#x3D;LAND matches Ireland.
     * @param limit The number of results to return (2-1000), default is 1000.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC. Default value is ASC
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts
     * @param format Format information for the response to the query, supported: format&#x3D;breakdown.
     * @param properties Property name to be returned from account specific properties.
     */
    public getAllAccounts(statusEq?: string, tierEq?: string, parentEq?: string, endMarketEq?: string, countryLike?: string, limit?: number, after?: string, order?: string, include?: string, format?: string, properties?: string, callback?: (error: any, data?: AccountInfoList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (statusEq !== undefined) {
            queryParameters["status__eq"] = statusEq;
        }
        if (tierEq !== undefined) {
            queryParameters["tier__eq"] = tierEq;
        }
        if (parentEq !== undefined) {
            queryParameters["parent__eq"] = parentEq;
        }
        if (endMarketEq !== undefined) {
            queryParameters["end_market__eq"] = endMarketEq;
        }
        if (countryLike !== undefined) {
            queryParameters["country__like"] = countryLike;
        }
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (format !== undefined) {
            queryParameters["format"] = format;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfoList>({
            url: "/v3/accounts",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API keys of a group.
     * An endpoint for listing the API keys of the group with details.
     * @param accountID Account ID.
     * @param groupID The ID of the group whose API keys are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getApiKeysOfAccountGroup(accountID: string, groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfAccountApikey(accountID: string, apiKey: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the user.
     * An endpoint for retrieving groups of the user.
     * @param accountID Account ID.
     * @param userId The ID of the user whose details are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfAccountUser(accountID: string, userId: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get users of a group.
     * An endpoint for listing users of the group with details.
     * @param accountID Account ID.
     * @param groupID The ID of the group whose users are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getUsersOfAccountGroup(accountID: string, groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: UserInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserInfoRespList>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeAccountApiKeyFromGroups(accountID: string, apiKey: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove user from groups.
     * An endpoint for removing user from groups.
     * @param accountID Account ID.
     * @param userId The ID of the user to be removed from the group.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeAccountUserFromGroups(accountID: string, userId: string, body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/users/{user-id}/groups".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove API keys from a group.
     * An endpoint for removing API keys from groups.
     * @param accountID Account ID.
     * @param groupID A list of API keys to be removed from the group.
     * @param body 
     */
    public removeApiKeysFromAccountGroup(accountID: string, groupID: string, body?: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/api-keys".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove users from a group.
     * An endpoint for removing users from groups.
     * @param accountID Account ID.
     * @param groupID 
     * @param body 
     */
    public removeUsersFromAccountGroup(accountID: string, groupID: string, body?: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/accounts/{accountID}/policy-groups/{groupID}/users".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Reset the secret key.
     * An endpoint for resetting the secret key of the API key.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be reset.
     */
    public resetAccountApiKeySecret(accountID: string, apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}/reset-secret".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Update attributes of an existing account.
     * An endpoint for updating an account.
     * @param accountID The ID of the account to be updated.
     * @param body Details of the account to be updated.
     */
    public updateAccount(accountID: string, body: AccountUpdateRootReq, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/{accountID}".replace("{" + "accountID" + "}", String(accountID)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param accountID Account ID.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateAccountApiKey(accountID: string, apiKey: string, body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/accounts/{accountID}/api-keys/{apiKey}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "apiKey" + "}", String(apiKey)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.
     * @param accountID Account ID.
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    public updateAccountCertificate(accountID: string, certId: string, body: TrustedCertificateUpdateReq, callback?: (error: any, data?: TrustedCertificateInternalResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateInternalResp>({
            url: "/v3/accounts/{accountID}/trusted-certificates/{cert-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "cert-id" + "}", String(certId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update a policy.
     * An endpoint for updating a policy.
     * @param accountID Account ID.
     * @param policyId The ID the policy to be retrieved.
     * @param body The details of the policy to be updated.
     */
    public updateAccountPolicy(accountID: string, policyId: string, body: PolicyUpdateReq, callback?: (error: any, data?: PolicyInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "policyId" is set
        if (policyId === null || policyId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'policyId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<PolicyInfo>({
            url: "/v3/accounts/{accountID}/policies/{policy-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "policy-id" + "}", String(policyId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update user details.
     * An endpoint for updating user details.
     * @param accountID Account ID.
     * @param userId The ID of the user to be updated.
     * @param body A user object with attributes.
     */
    public updateAccountUser(accountID: string, userId: string, body: AdminUserUpdateReq, callback?: (error: any, data?: UserUpdateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserUpdateResp>({
            url: "/v3/accounts/{accountID}/users/{user-id}".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Validate the user email.
     * An endpoint for validating the user email.
     * @param accountID Account ID.
     * @param userId The ID of the user whose email is validated.
     */
    public validateAccountUserEmail(accountID: string, userId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "accountID" is set
        if (accountID === null || accountID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'accountID' missing."));
            }
            return;
        }
        // verify required parameter "userId" is set
        if (userId === null || userId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'userId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/accounts/{accountID}/users/{user-id}/validate-email".replace("{" + "accountID" + "}", String(accountID)).replace("{" + "user-id" + "}", String(userId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
}
/**
 * DeveloperApi
 */
export class DeveloperApi extends ApiBase {

    /**
     * Add user to a list of groupS.
     * An endpoint for adding user to groups.
     * @param body A list of IDs of the groups to be updated.
     */
    public addMeToGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/me/groups",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Add API key to a list of groups.
     * An endpoint for adding API key to groups.
     * @param body A list of IDs of the groups to be updated.
     */
    public addMyApiKeyToGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/me/groups",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Create a new API key.
     * An endpoint for creating a new API key.   **Example usage:** &#x60;curl -X POST https://api.us-east-1.mbedcloud.com/v3/api-keys -d &#39;{\&quot;name\&quot;: \&quot;MyKey1\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body The details of the API key to be created.
     */
    public createApiKey(body: ApiKeyInfoReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Delete API key.
     * An endpoint for deleting the API key.   **Example usage:** &#x60;curl -X DELETE https://api.us-east-1.mbedcloud.com/v3/api-keys/{apikey-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param apiKey The ID of the API key to be deleted.
     */
    public deleteApiKey(apiKey: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a trusted certificate by ID.
     * An endpoint for deleting a trusted certificate.
     * @param certId The ID of the trusted certificate to be deleted.
     */
    public deleteCertificate(certId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all API keys
     * An endpoint for retrieving API keys in an array, optionally filtered by the owner.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param keyEq API key filter.
     * @param ownerEq Owner name filter.
     */
    public getAllApiKeys(limit?: number, after?: string, order?: string, include?: string, keyEq?: string, ownerEq?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (keyEq !== undefined) {
            queryParameters["key__eq"] = keyEq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/api-keys",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all trusted certificates.
     * An endpoint for retrieving trusted certificates in an array.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for certificate name
     * @param serviceEq Service filter, either lwm2m or bootstrap
     * @param expireEq Expire filter in days
     * @param deviceExecutionModeEq Device execution mode, as 1 for developer certificates or as another natural integer value
     * @param deviceExecutionModeNeq Device execution mode not equals filter
     * @param ownerEq Owner name filter
     * @param enrollmentModeEq Enrollment mode filter
     * @param issuerLike Issuer filter. Finds all matches where the filter value is a case insensitive substring of the result. Example: issuer__like&#x3D;cn&#x3D;iss matches CN&#x3D;issuer.
     * @param subjectLike Subject filter. Finds all matches where the filter value is a case insensitive substring of the result. Example: subject__like&#x3D;cn&#x3D;su matches CN&#x3D;subject.
     */
    public getAllCertificates(limit?: number, after?: string, order?: string, include?: string, nameEq?: string, serviceEq?: string, expireEq?: number, deviceExecutionModeEq?: number, deviceExecutionModeNeq?: number, ownerEq?: string, enrollmentModeEq?: boolean, issuerLike?: string, subjectLike?: string, callback?: (error: any, data?: TrustedCertificateRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }
        if (serviceEq !== undefined) {
            queryParameters["service__eq"] = serviceEq;
        }
        if (expireEq !== undefined) {
            queryParameters["expire__eq"] = expireEq;
        }
        if (deviceExecutionModeEq !== undefined) {
            queryParameters["device_execution_mode__eq"] = deviceExecutionModeEq;
        }
        if (deviceExecutionModeNeq !== undefined) {
            queryParameters["device_execution_mode__neq"] = deviceExecutionModeNeq;
        }
        if (ownerEq !== undefined) {
            queryParameters["owner__eq"] = ownerEq;
        }
        if (enrollmentModeEq !== undefined) {
            queryParameters["enrollment_mode__eq"] = enrollmentModeEq;
        }
        if (issuerLike !== undefined) {
            queryParameters["issuer__like"] = issuerLike;
        }
        if (subjectLike !== undefined) {
            queryParameters["subject__like"] = subjectLike;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateRespList>({
            url: "/v3/trusted-certificates",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get all group information.
     * An endpoint for retrieving all group information.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     * @param nameEq Filter for group name
     */
    public getAllGroups(limit?: number, after?: string, order?: string, include?: string, nameEq?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (nameEq !== undefined) {
            queryParameters["name__eq"] = nameEq;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/policy-groups",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.
     * @param apiKey The ID of the API key to be retrieved.
     */
    public getApiKey(apiKey: string, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get the API keys of a group.
     * An endpoint for listing the API keys of the group with details.
     * @param groupID The ID of the group whose API keys are retrieved.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getApiKeysOfGroup(groupID: string, limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: ApiKeyInfoRespList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoRespList>({
            url: "/v3/policy-groups/{groupID}/api-keys".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get trusted certificate by ID.
     * An endpoint for retrieving a trusted certificate by ID.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/trusted-certificates/{cert-id} -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param certId The ID of the trusted certificate to be retrieved.
     */
    public getCertificate(certId: string, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get group information.
     * An endpoint for getting general information about the group.
     * @param groupID The ID of the group to be retrieved.
     */
    public getGroupSummary(groupID: string, callback?: (error: any, data?: GroupSummary, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummary>({
            url: "/v3/policy-groups/{groupID}".replace("{" + "groupID" + "}", String(groupID)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the API key.
     * An endpoint for retrieving groups of the API key.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getGroupsOfMyApiKey(limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/api-keys/me/groups",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get account info.
     * Returns detailed information about the account.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/accounts/me?include&#x3D;policies -H &#39;Authorization: Bearer API_KEY&#39;&#x60;.
     * @param include Comma separated additional data to return. Currently supported: limits, policies, sub_accounts.
     * @param properties Property name to be returned from account specific properties.
     */
    public getMyAccountInfo(include?: string, properties?: string, callback?: (error: any, data?: AccountInfo, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (include !== undefined) {
            queryParameters["include"] = include;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountInfo>({
            url: "/v3/accounts/me",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get accounts of the user.
     * An endpoint for retrieving the accounts of the logged in user.
     */
    public getMyAccounts(callback?: (error: any, data?: AccountResponseList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<AccountResponseList>({
            url: "/v3/users/me/accounts",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get API key details.
     * An endpoint for retrieving API key details.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/api-keys/me -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     */
    public getMyApiKey(callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/me",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get groups of the user.
     * An endpoint for retrieving groups of the user.
     * @param limit The number of results to return (2-1000), default is 50.
     * @param after The entity ID to fetch after the given one.
     * @param order The order of the records based on creation time, ASC or DESC; by default ASC
     * @param include Comma separated additional data to return. Currently supported: total_count
     */
    public getMyGroups(limit?: number, after?: string, order?: string, include?: string, callback?: (error: any, data?: GroupSummaryList, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<GroupSummaryList>({
            url: "/v3/users/me/groups",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Details of the current user.
     * An endpoint for retrieving the details of the logged in user.   **Example usage:** &#x60;curl https://api.us-east-1.mbedcloud.com/v3/users/me -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param scratchCodes Request to regenerate new emergency scratch codes.
     * @param properties Request to return account specific user property values according to the given property name.
     * @param include Comma separated additional data to return. Currently supported: active_sessions
     */
    public getMyUser(scratchCodes?: string, properties?: string, include?: string, callback?: (error: any, data?: MyUserInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (scratchCodes !== undefined) {
            queryParameters["scratch_codes"] = scratchCodes;
        }
        if (properties !== undefined) {
            queryParameters["properties"] = properties;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<MyUserInfoResp>({
            url: "/v3/users/me",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Remove API keys from a group.
     * An endpoint for removing API keys from groups.
     * @param groupID The ID of the group whose API keys are removed.
     * @param body A list of API keys to be removed from the group.
     */
    public removeApiKeysFromGroup(groupID: string, body: SubjectList, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "groupID" is set
        if (groupID === null || groupID === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'groupID' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/policy-groups/{groupID}/api-keys".replace("{" + "groupID" + "}", String(groupID)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove user from a group.
     * An endpoint for removing user from groups.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeMeFromGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/users/me/groups",
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Remove API key from groups.
     * An endpoint for removing API key from groups.
     * @param body A list of IDs of the groups to be updated.
     */
    public removeMyApiKeyFromGroups(body: Array<string>, callback?: (error: any, data?: UpdatedResponse, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdatedResponse>({
            url: "/v3/api-keys/me/groups",
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.
     * @param apiKey The ID of the API key to be updated.
     * @param body New API key attributes to be stored.
     */
    public updateApiKey(apiKey: string, body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "apiKey" is set
        if (apiKey === null || apiKey === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'apiKey' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/{apiKey}".replace("{" + "apiKey" + "}", String(apiKey)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update trusted certificate.
     * An endpoint for updating existing trusted certificates.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/trusted-certificates/{cert-id} -d {\&quot;description\&quot;: \&quot;very important cert\&quot;} -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param certId The ID of the trusted certificate to be updated.
     * @param body A trusted certificate object with attributes.
     */
    public updateCertificate(certId: string, body: TrustedCertificateUpdateReq, callback?: (error: any, data?: TrustedCertificateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "certId" is set
        if (certId === null || certId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'certId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<TrustedCertificateResp>({
            url: "/v3/trusted-certificates/{cert-id}".replace("{" + "cert-id" + "}", String(certId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update API key details.
     * An endpoint for updating API key details.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/api-keys/me -d &#39;{\&quot;name\&quot;: \&quot;TestApiKey25\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body New API key attributes to be stored.
     */
    public updateMyApiKey(body: ApiKeyUpdateReq, callback?: (error: any, data?: ApiKeyInfoResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<ApiKeyInfoResp>({
            url: "/v3/api-keys/me",
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
    /**
     * Update user details.
     * An endpoint for updating the details of the logged in user.   **Example usage:** &#x60;curl -X PUT https://api.us-east-1.mbedcloud.com/v3/users/me -d &#39;{\&quot;address\&quot;: \&quot;1007 Mountain Drive\&quot;}&#39; -H &#39;content-type: application/json&#39; -H &#39;Authorization: Bearer API_KEY&#39;&#x60;
     * @param body New attributes for the logged in user.
     */
    public updateMyUser(body: UserUpdateReq, callback?: (error: any, data?: UserUpdateResp, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "application/json"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UserUpdateResp>({
            url: "/v3/users/me",
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: body,
        }, callback);
    }
}
