/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Update Service API
 * This is the API documentation for the Mbed deployment service, which is part of the update service.
 *
 * OpenAPI spec version: 3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import superagent = require("superagent");
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export namespace CampaignDeviceMetadata {
    export type DeploymentStateEnum = "pending" | "updated_connector_channel" | "failed_connector_channel_update" | "deployed" | "manifestremoved" | "deregistered";
}
export interface CampaignDeviceMetadata {
    /**
     * The device's campaign ID
     */
    "campaign"?: string;
    /**
     * The time the campaign was created
     */
    "created_at"?: Date;
    /**
     * The state of the update campaign on the device
     */
    "deployment_state"?: CampaignDeviceMetadata.DeploymentStateEnum;
    /**
     * Description
     */
    "description"?: string;
    /**
     * The device ID
     */
    "device_id"?: string;
    /**
     * API resource entity version
     */
    "etag"?: string;
    /**
     * The metadata record ID
     */
    "id"?: string;
    /**
     * How the firmware is delivered (connector or direct)
     */
    "mechanism"?: string;
    /**
     * The Cloud Connect URL
     */
    "mechanism_url"?: string;
    /**
     * The record name
     */
    "name"?: string;
    /**
     * Entity name: always 'update-campaign-device-metadata'
     */
    "object"?: string;
    /**
     * This time this record was modified in the database format: date-time
     */
    "updated_at"?: Date;
}

export namespace CampaignDeviceMetadataPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface CampaignDeviceMetadataPage {
    /**
     * The entity ID to fetch after the given one
     */
    "after"?: string;
    /**
     * A list of entities
     */
    "data"?: Array<CampaignDeviceMetadata>;
    /**
     * Flag indicating whether there are more results
     */
    "has_more"?: boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to total_count
     */
    "limit"?: number;
    /**
     * Entity name: always 'list'
     */
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: CampaignDeviceMetadataPage.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    "total_count"?: number;
}

export interface FirmwareImage {
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The firmware image file URL
     */
    "datafile": string;
    /**
     * Checksum (sha256) generated for the datafile
     */
    "datafile_checksum": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The description of the object
     */
    "description": string;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The firmware image ID
     */
    "id": string;
    /**
     * The firmware image name
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
}

export interface FirmwareImageEqNeqFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_checksum"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "updated_at"?: Date;
}

export interface FirmwareImageGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "updated_at"?: Date;
}

export interface FirmwareImageInNinFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_checksum"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "updated_at"?: Date;
}

export namespace FirmwareImagePage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareImagePage {
    "after"?: string;
    "data"?: Array<FirmwareImage>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records based on creation time, `ASC` or `DESC`; by default `ASC`.
     */
    "order"?: FirmwareImagePage.OrderEnum;
    "total_count"?: number;
}

export interface FirmwareManifest {
    /**
     * The time the object was created
     */
    "created_at": Date;
    /**
     * The URL of the firmware manifest binary
     */
    "datafile": string;
    /**
     * Size of the datafile in bytes
     */
    "datafile_size"?: number;
    /**
     * The description of the firmware manifest
     */
    "description": string;
    /**
     * The class of the device
     */
    "device_class": string;
    /**
     * The entity instance signature
     */
    "etag": Date;
    /**
     * The firmware manifest ID
     */
    "id": string;
    /**
     * The key table of pre-shared keys for devices
     */
    "key_table"?: string;
    /**
     * The name of the object
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    /**
     * The firmware manifest version as a timestamp
     */
    "timestamp": Date;
    /**
     * The time the object was updated
     */
    "updated_at": Date;
}

export interface FirmwareManifestEqNeqFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "device_class"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "timestamp"?: Date;
    "updated_at"?: Date;
}

export interface FirmwareManifestGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "timestamp"?: Date;
    "updated_at"?: Date;
}

export interface FirmwareManifestInNinFilter {
    "created_at"?: Date;
    "datafile"?: string;
    "datafile_size"?: number;
    "description"?: string;
    "device_class"?: string;
    "etag"?: Date;
    "id"?: string;
    "name"?: string;
    "timestamp"?: Date;
    "updated_at"?: Date;
}

export namespace FirmwareManifestPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareManifestPage {
    "after"?: string;
    "data"?: Array<FirmwareManifest>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: FirmwareManifestPage.OrderEnum;
    "total_count"?: number;
}

export namespace UpdateCampaign {
    export type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaign {
    /**
     * The time the update campaign was created
     */
    "created_at"?: Date;
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The entity instance signature
     */
    "etag"?: string;
    /**
     * The campaign finish timestamp
     */
    "finished"?: Date;
    /**
     * The campaign ID
     */
    "id"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    /**
     * The current phase of the campaign.
     */
    "phase"?: string;
    "root_manifest_id"?: string;
    "root_manifest_url"?: string;
    "started_at"?: Date;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaign.StateEnum;
    /**
     * The time the object was updated
     */
    "updated_at"?: Date;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}

export interface UpdateCampaignEqNeqFilter {
    "created_at"?: Date;
    "description"?: string;
    "device_filter"?: string;
    "etag"?: Date;
    "finished"?: Date;
    "id"?: string;
    "name"?: string;
    "root_manifest_id"?: string;
    "started_at"?: Date;
    "state"?: string;
    "updated_at"?: Date;
    "when"?: Date;
}

export interface UpdateCampaignGteLteFilter {
    "created_at"?: Date;
    "etag"?: Date;
    "finished"?: Date;
    "started_at"?: Date;
    "updated_at"?: Date;
    "when"?: Date;
}

export interface UpdateCampaignInNinFilter {
    "created_at"?: Date;
    "description"?: string;
    "device_filter"?: string;
    "etag"?: Date;
    "finished"?: Date;
    "id"?: string;
    "name"?: string;
    "root_manifest_id"?: string;
    "started_at"?: Date;
    "state"?: string;
    "updated_at"?: Date;
    "when"?: Date;
}

export namespace UpdateCampaignPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface UpdateCampaignPage {
    "after"?: string;
    "data"?: Array<UpdateCampaign>;
    "has_more"?: boolean;
    "limit"?: number;
    "object"?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    "order"?: UpdateCampaignPage.OrderEnum;
    "total_count"?: number;
}

export namespace UpdateCampaignPatchRequest {
    export type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPatchRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter"?: string;
    /**
     * The campaign name
     */
    "name"?: string;
    /**
     * The API resource entity
     */
    "object"?: string;
    "root_manifest_id"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPatchRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}

export namespace UpdateCampaignPostRequest {
    export type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPostRequest {
    /**
     * The optional description of the campaign
     */
    "description"?: string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The name for this campaign
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object"?: string;
    "root_manifest_id"?: string;
    /**
     * The state of the campaign
     */
    "state"?: UpdateCampaignPostRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when"?: Date;
}

export namespace UpdateCampaignPutRequest {
    export type StateEnum = "draft" | "scheduled" | "allocatingquota" | "allocatedquota" | "quotaallocationfailed" | "checkingmanifest" | "checkedmanifest" | "devicefetch" | "devicecopy" | "devicecheck" | "publishing" | "deploying" | "deployed" | "manifestremoved" | "expired" | "stopping" | "autostopped" | "userstopped" | "conflict";
}
export interface UpdateCampaignPutRequest {
    /**
     * An optional description of the campaign
     */
    "description": string;
    /**
     * The filter for the devices the campaign will target
     */
    "device_filter": string;
    /**
     * The campaign's name
     */
    "name": string;
    /**
     * The API resource entity
     */
    "object": string;
    "root_manifest_id": string;
    /**
     * The state of the campaign
     */
    "state": UpdateCampaignPutRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    "when": Date;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {

    /**
     * Create an image
     * Create firmware image.
     * @param datafile The firmware image file to upload
     * @param name The name of the firmware image
     * @param description The description of the firmware image
     */
    public firmwareImageCreate(datafile: any, name: string, description?: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "multipart/form-data"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete an image
     * Delete firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageDestroy(imageId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * List all images
     * List all firmware images.
     * @param limit How many firmware images to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |       Field       | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-----------------:|:----------------:|:-------------:|:-------------:| |     created_at    |         ✓        |       ✓       |       ✓       | |      datafile     |         ✓        |       ✓       |               | | datafile_checksum |         ✓        |       ✓       |               | |   datafile_size   |         ✓        |       ✓       |               | |    description    |         ✓        |       ✓       |               | |        etag       |         ✓        |       ✓       |       ✓       | |         id        |         ✓        |       ✓       |               | |        name       |         ✓        |       ✓       |               | |     timestamp     |         ✓        |       ✓       |       ✓       | |     updated_at    |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;myimage&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;myimage&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareImageList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareImagePage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImagePage>({
            url: "/v3/firmware-images/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get an image
     * Retrieve firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageRetrieve(imageId: string, callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareImage>({
            url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Create a manifest
     * Create firmware manifest.
     * @param datafile The manifest file to create. The API gateway enforces the account-specific file size.
     * @param name The name of the firmware manifest
     * @param description The description of the firmware manifest
     * @param keyTable The key table of pre-shared keys for devices
     */
    public firmwareManifestCreate(datafile: any, name: string, description?: string, keyTable?: any, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (keyTable !== undefined) {
            formParams["key_table"] = keyTable;
        }
        useFormData = true;

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "multipart/form-data"
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Delete a manifest
     * Delete firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestDestroy(manifestId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * List manifests
     * List firmware manifests.
     * @param limit How many firmware manifests to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page.
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |     Field     | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-------------:|:----------------:|:-------------:|:-------------:| |   created_at  |         ✓        |       ✓       |       ✓       | |    datafile   |         ✓        |       ✓       |               | | datafile_size |         ✓        |       ✓       |               | |  description  |         ✓        |       ✓       |               | |  device_class |         ✓        |       ✓       |               | |      etag     |         ✓        |       ✓       |       ✓       | |       id      |         ✓        |       ✓       |               | |      name     |         ✓        |       ✓       |               | |   timestamp   |         ✓        |       ✓       |       ✓       | |   updated_at  |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;mymanifest&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;mymanifest&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-manifest1,fw-manifest2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareManifestList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: FirmwareManifestPage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifestPage>({
            url: "/v3/firmware-manifests/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get a manifest
     * Retrieve firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestRetrieve(manifestId: string, callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<FirmwareManifest>({
            url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Create a campaign
     * Create an update campaign.
     * @param campaign Update campaign
     */
    public updateCampaignCreate(campaign: UpdateCampaignPostRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/",
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: campaign,
        }, callback);
    }
    /**
     * Delete a campaign
     * Delete an update campaign.
     * @param campaignId The ID of the update campaign
     */
    public updateCampaignDestroy(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "DELETE",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * List all campaigns
     * Get update campaigns for devices specified by a filter.
     * @param limit How many update campaigns to retrieve
     * @param order The order of the records. Acceptable values: ASC, DESC. Default: ASC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;   ###### Filterable fields:    The below table lists all the fields that can be filtered on with certain filters:    |       Field      | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte |   |:----------------:|:----------------:|:-------------:|:-------------:|   |    created_at    |         ✓        |       ✓       |       ✓       |   |    description   |         ✓        |       ✓       |               |   |   device_filter  |         ✓        |       ✓       |               |   |       etag       |         ✓        |       ✓       |       ✓       |   |     finished     |         ✓        |       ✓       |       ✓       |   |        id        |         ✓        |       ✓       |               |   |       name       |         ✓        |       ✓       |               |   | root_manifest_id |         ✓        |       ✓       |               |   |    started_at    |         ✓        |       ✓       |       ✓       |   |       state      |         ✓        |       ✓       |               |   |    updated_at    |         ✓        |       ✓       |       ✓       |   |       when       |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by campaign properties** &#x60;state__eq&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]&#x60;  &#x60;root_manifest_id__eq&#x3D;43217771234242e594ddb433816c498a&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;state__eq&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignList(limit?: number, order?: string, after?: string, filter?: string, include?: string, callback?: (error: any, data?: UpdateCampaignPage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaignPage>({
            url: "/v3/update-campaigns/",
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * List all campaign device metadata
     * Get campaign device metadata.
     * @param campaignId The update campaign ID
     * @param limit How many objects to retrieve in the page
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignMetadataList(campaignId: string, limit?: number, order?: string, after?: string, include?: string, callback?: (error: any, data?: CampaignDeviceMetadataPage, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<CampaignDeviceMetadataPage>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get a campaign device metadata
     * Get update campaign metadata.
     * @param campaignId The update campaign ID
     * @param campaignDeviceMetadataId The campaign device metadata ID
     */
    public updateCampaignMetadataRetrieve(campaignId: string, campaignDeviceMetadataId: string, callback?: (error: any, data?: CampaignDeviceMetadata, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaignDeviceMetadataId" is set
        if (campaignDeviceMetadataId === null || campaignDeviceMetadataId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignDeviceMetadataId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<CampaignDeviceMetadata>({
            url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/{campaign_device_metadata_id}/".replace("{" + "campaign_id" + "}", String(campaignId)).replace("{" + "campaign_device_metadata_id" + "}", String(campaignDeviceMetadataId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Stop a running campaign
     * Stop a running update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignMetadataStop(campaignId: string, callback?: (error: any, data?: any, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<null>({
            url: "/v3/update-campaigns/{campaign_id}/stop".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "POST",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Get a campaign.
     * Get an update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignRetrieve(campaignId: string, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "GET",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
        }, callback);
    }
    /**
     * Modify a campaign
     * Modify an update campaign.
     * @param campaignId 
     * @param campaign Update campaign
     */
    public updateCampaignUpdate(campaignId: string, campaign: UpdateCampaignPutRequest, callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any, requestOptions?: { [key: string]: any }): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [
            "application/json"
        ];

        return this.request<UpdateCampaign>({
            url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
            method: "PUT",
            headers: headerParams,
            query: queryParameters,
            formParams: formParams,
            useFormData: useFormData,
            contentTypes: contentTypes,
            acceptTypes: acceptTypes,
            requestOptions: requestOptions,
            body: campaign,
        }, callback);
    }
}
